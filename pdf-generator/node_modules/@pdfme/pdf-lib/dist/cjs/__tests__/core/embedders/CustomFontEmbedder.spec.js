"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fontkit_1 = __importDefault(require("@pdf-lib/fontkit"));
const fs_1 = __importDefault(require("fs"));
const index_1 = require("../../../src/index");
const ubuntuFont = fs_1.default.readFileSync('./assets/fonts/ubuntu/Ubuntu-R.ttf');
describe(`CustomFontEmbedder`, () => {
    it(`can be constructed with CustomFontEmbedder.for(...)`, async () => {
        const embedder = await index_1.CustomFontEmbedder.for(fontkit_1.default, ubuntuFont);
        expect(embedder).toBeInstanceOf(index_1.CustomFontEmbedder);
    });
    it(`exposes the font's name`, async () => {
        const embedder = await index_1.CustomFontEmbedder.for(fontkit_1.default, new Uint8Array(ubuntuFont));
        expect(embedder.fontName).toBe('Ubuntu');
    });
    it(`can set a custom font name`, async () => {
        const customName = 'abc123';
        const embedder = await index_1.CustomFontEmbedder.for(fontkit_1.default, new Uint8Array(ubuntuFont), customName);
        expect(embedder.customName).toBe(customName);
    });
    it(`can embed font dictionaries into PDFContexts without a predefined ref`, async () => {
        const context = index_1.PDFContext.create();
        const embedder = await index_1.CustomFontEmbedder.for(fontkit_1.default, new Uint8Array(ubuntuFont));
        expect(context.enumerateIndirectObjects().length).toBe(0);
        const ref = await embedder.embedIntoContext(context);
        expect(context.enumerateIndirectObjects().length).toBe(5);
        expect(context.lookup(ref)).toBeInstanceOf(index_1.PDFDict);
    });
    it(`can embed font dictionaries into PDFContexts with a predefined ref`, async () => {
        const context = index_1.PDFContext.create();
        const predefinedRef = index_1.PDFRef.of(9999);
        const embedder = await index_1.CustomFontEmbedder.for(fontkit_1.default, new Uint8Array(ubuntuFont));
        expect(context.enumerateIndirectObjects().length).toBe(0);
        const ref = await embedder.embedIntoContext(context, predefinedRef);
        expect(context.enumerateIndirectObjects().length).toBe(5);
        expect(context.lookup(predefinedRef)).toBeInstanceOf(index_1.PDFDict);
        expect(ref).toBe(predefinedRef);
    });
    it(`can encode text strings into PDFHexString objects`, async () => {
        const text = 'Stuff and thingz!';
        const hexCodes = '00360057005801AA000300440051004700030057004B004C0051004A005D0004';
        const embedder = await index_1.CustomFontEmbedder.for(fontkit_1.default, ubuntuFont);
        expect(embedder.encodeText(text)).toBeInstanceOf(index_1.PDFHexString);
        expect(String(embedder.encodeText(text))).toBe(String(index_1.PDFHexString.of(hexCodes)));
    });
    it(`can measure the width of text strings at the given font size`, async () => {
        const text = 'Stuff and thingz!';
        const embedder = await index_1.CustomFontEmbedder.for(fontkit_1.default, ubuntuFont);
        expect(embedder.widthOfTextAtSize(text, 12)).toBe(90.672);
        expect(embedder.widthOfTextAtSize(text, 24)).toBe(181.344);
    });
    it(`can measure the height of the font at the given size`, async () => {
        const embedder = await index_1.CustomFontEmbedder.for(fontkit_1.default, ubuntuFont);
        expect(embedder.heightOfFontAtSize(12)).toBeCloseTo(13.452);
        expect(embedder.heightOfFontAtSize(24)).toBeCloseTo(26.904);
    });
    it(`can measure the size of the font at a given height`, async () => {
        const embedder = await index_1.CustomFontEmbedder.for(fontkit_1.default, ubuntuFont);
        expect(embedder.sizeOfFontAtHeight(12)).toBeCloseTo(10.705);
        expect(embedder.sizeOfFontAtHeight(24)).toBeCloseTo(21.409);
    });
});
//# sourceMappingURL=CustomFontEmbedder.spec.js.map