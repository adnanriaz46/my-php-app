"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fontkit_1 = __importDefault(require("@pdf-lib/fontkit"));
const fs_1 = __importDefault(require("fs"));
const index_1 = require("../../../src/index");
const ubuntuFont = fs_1.default.readFileSync('./assets/fonts/ubuntu/Ubuntu-R.ttf');
describe(`CustomFontSubsetEmbedder`, () => {
    it(`can be constructed with CustomFontSubsetEmbedder.for(...)`, async () => {
        const embedder = await index_1.CustomFontSubsetEmbedder.for(fontkit_1.default, ubuntuFont);
        expect(embedder).toBeInstanceOf(index_1.CustomFontSubsetEmbedder);
    });
    it(`can embed standard font dictionaries into PDFContexts`, async () => {
        const context = index_1.PDFContext.create();
        const embedder = await index_1.CustomFontSubsetEmbedder.for(fontkit_1.default, new Uint8Array(ubuntuFont));
        expect(context.enumerateIndirectObjects().length).toBe(0);
        const ref = await embedder.embedIntoContext(context);
        expect(context.enumerateIndirectObjects().length).toBe(5);
        expect(context.lookup(ref)).toBeInstanceOf(index_1.PDFDict);
    });
    it(`can encode text strings into PDFHexString objects`, async () => {
        const text = 'Stuff and thingz!';
        const hexCodes = '00010002000300040005000600070008000500020009000A0007000B000C000D';
        const embedder = await index_1.CustomFontSubsetEmbedder.for(fontkit_1.default, ubuntuFont);
        expect(embedder.encodeText(text)).toBeInstanceOf(index_1.PDFHexString);
        expect(String(embedder.encodeText(text))).toBe(String(index_1.PDFHexString.of(hexCodes)));
    });
    it(`can measure the width of text strings at the given font size`, async () => {
        const text = 'Stuff and thingz!';
        const embedder = await index_1.CustomFontSubsetEmbedder.for(fontkit_1.default, ubuntuFont);
        expect(embedder.widthOfTextAtSize(text, 12)).toBe(90.672);
        expect(embedder.widthOfTextAtSize(text, 24)).toBe(181.344);
    });
    it(`can measure the height of the font at the given size`, async () => {
        const embedder = await index_1.CustomFontSubsetEmbedder.for(fontkit_1.default, ubuntuFont);
        expect(embedder.heightOfFontAtSize(12)).toBeCloseTo(13.452);
        expect(embedder.heightOfFontAtSize(24)).toBeCloseTo(26.904);
    });
    it(`can measure the size of the font at a given height`, async () => {
        const embedder = await index_1.CustomFontSubsetEmbedder.for(fontkit_1.default, ubuntuFont);
        expect(embedder.sizeOfFontAtHeight(12)).toBeCloseTo(10.705);
        expect(embedder.sizeOfFontAtHeight(24)).toBeCloseTo(21.409);
    });
});
//# sourceMappingURL=CustomFontSubsetEmbedder.spec.js.map