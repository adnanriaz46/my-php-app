"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("../../../src/core");
const utils_1 = require("../../../src/utils");
describe(`PDFBool`, () => {
    it(`cannot be publicly constructed`, () => {
        expect(() => new core_1.PDFBool({}, true)).toThrow(new core_1.PrivateConstructorError(core_1.PDFBool.name));
    });
    it(`can be converted to a boolean`, () => {
        expect(core_1.PDFBool.True.asBoolean()).toBe(true);
        expect(core_1.PDFBool.False.asBoolean()).toBe(false);
    });
    it(`can be cloned`, () => {
        expect(core_1.PDFBool.True.clone()).toBe(core_1.PDFBool.True);
        expect(core_1.PDFBool.False.clone()).toBe(core_1.PDFBool.False);
    });
    it(`can be converted to a string`, () => {
        expect(String(core_1.PDFBool.True)).toBe('true');
        expect(String(core_1.PDFBool.False)).toBe('false');
    });
    it(`can provide its size in bytes`, () => {
        expect(core_1.PDFBool.True.sizeInBytes()).toBe(4);
        expect(core_1.PDFBool.False.sizeInBytes()).toBe(5);
    });
    it(`can be serialized when true`, () => {
        const buffer = new Uint8Array(8).fill((0, utils_1.toCharCode)(' '));
        expect(core_1.PDFBool.True.copyBytesInto(buffer, 3)).toBe(4);
        expect(buffer).toEqual((0, utils_1.typedArrayFor)('   true '));
    });
    it(`can be serialized when false`, () => {
        const buffer = new Uint8Array(9).fill((0, utils_1.toCharCode)(' '));
        expect(core_1.PDFBool.False.copyBytesInto(buffer, 1)).toBe(5);
        expect(buffer).toEqual((0, utils_1.typedArrayFor)(' false   '));
    });
});
//# sourceMappingURL=PDFBool.spec.js.map