"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("../../../src/core");
const utils_1 = require("../../../src/utils");
describe(`PDFName`, () => {
    it(`can be constructed from PDFName.of(...)`, () => {
        expect(core_1.PDFName.of('foobar')).toBeInstanceOf(core_1.PDFName);
        expect(core_1.PDFName.of('A;Name_With-***Characters?')).toBeInstanceOf(core_1.PDFName);
        expect(core_1.PDFName.of('paired#28#29parentheses')).toBeInstanceOf(core_1.PDFName);
    });
    it(`cannot be publicly constructed`, () => {
        expect(() => new core_1.PDFName({}, 'stuff')).toThrow(new core_1.PrivateConstructorError(core_1.PDFName.name));
    });
    it(`returns the same instance when given the same value`, () => {
        expect(core_1.PDFName.of('foobar')).toBe(core_1.PDFName.of('foobar'));
        expect(core_1.PDFName.of('A;Name_With-***Characters?')).toBe(core_1.PDFName.of('A;Name_With-***Characters?'));
        expect(core_1.PDFName.of('paired#28#29parentheses')).toBe(core_1.PDFName.of('paired#28#29parentheses'));
    });
    it(`decodes hex codes in the values`, () => {
        expect(core_1.PDFName.of('Lime#20Green')).toBe(core_1.PDFName.of('Lime Green'));
        expect(core_1.PDFName.of('paired#28#29parentheses')).toBe(core_1.PDFName.of('paired()parentheses'));
        expect(core_1.PDFName.of('The_Key_of_F#23_Minor')).toBe(core_1.PDFName.of('The_Key_of_F#_Minor'));
        expect(core_1.PDFName.of('A#42')).toBe(core_1.PDFName.of('AB'));
        expect(core_1.PDFName.of('Identity#2DH')).toBe(core_1.PDFName.of('Identity-H'));
        expect(core_1.PDFName.of('#40')).toBe(core_1.PDFName.of('@'));
        expect(core_1.PDFName.of('#41')).toBe(core_1.PDFName.of('A'));
        expect(core_1.PDFName.of('#42')).toBe(core_1.PDFName.of('B'));
        expect(core_1.PDFName.of('#43')).toBe(core_1.PDFName.of('C'));
        expect(core_1.PDFName.of('#44')).toBe(core_1.PDFName.of('D'));
        expect(core_1.PDFName.of('#45')).toBe(core_1.PDFName.of('E'));
        expect(core_1.PDFName.of('#46')).toBe(core_1.PDFName.of('F'));
        expect(core_1.PDFName.of('#47')).toBe(core_1.PDFName.of('G'));
        expect(core_1.PDFName.of('#48')).toBe(core_1.PDFName.of('H'));
        expect(core_1.PDFName.of('#49')).toBe(core_1.PDFName.of('I'));
        expect(core_1.PDFName.of('#4A')).toBe(core_1.PDFName.of('J'));
        expect(core_1.PDFName.of('#4B')).toBe(core_1.PDFName.of('K'));
        expect(core_1.PDFName.of('#4C')).toBe(core_1.PDFName.of('L'));
        expect(core_1.PDFName.of('#4D')).toBe(core_1.PDFName.of('M'));
        expect(core_1.PDFName.of('#4E')).toBe(core_1.PDFName.of('N'));
        expect(core_1.PDFName.of('#4F')).toBe(core_1.PDFName.of('O'));
    });
    it(`encodes hashes, whitespace, and delimiters when serialized`, () => {
        expect(core_1.PDFName.of('Foo#').toString()).toBe('/Foo#23');
        // Note that the \0 shouldn't ever be written into a name,
        // but we'll support it for parsing flexibility sake
        expect(core_1.PDFName.of('Foo\0').toString()).toBe('/Foo#00');
        expect(core_1.PDFName.of('Foo\t').toString()).toBe('/Foo#09');
        expect(core_1.PDFName.of('Foo\n').toString()).toBe('/Foo#0A');
        expect(core_1.PDFName.of('Foo\f').toString()).toBe('/Foo#0C');
        expect(core_1.PDFName.of('Foo\r').toString()).toBe('/Foo#0D');
        expect(core_1.PDFName.of('Foo ').toString()).toBe('/Foo#20');
        expect(core_1.PDFName.of('Foo(').toString()).toBe('/Foo#28');
        expect(core_1.PDFName.of('Foo)').toString()).toBe('/Foo#29');
        expect(core_1.PDFName.of('Foo<').toString()).toBe('/Foo#3C');
        expect(core_1.PDFName.of('Foo>').toString()).toBe('/Foo#3E');
        expect(core_1.PDFName.of('Foo[').toString()).toBe('/Foo#5B');
        expect(core_1.PDFName.of('Foo]').toString()).toBe('/Foo#5D');
        expect(core_1.PDFName.of('Foo{').toString()).toBe('/Foo#7B');
        expect(core_1.PDFName.of('Foo}').toString()).toBe('/Foo#7D');
        expect(core_1.PDFName.of('Foo/').toString()).toBe('/Foo#2F');
        expect(core_1.PDFName.of('Foo%').toString()).toBe('/Foo#25');
    });
    it(`can be cloned`, () => {
        expect(core_1.PDFName.of('foobar').clone()).toBe(core_1.PDFName.of('foobar'));
        expect(core_1.PDFName.of('Lime#20Green').clone()).toBe(core_1.PDFName.of('Lime Green'));
    });
    it(`can be converted to a string`, () => {
        expect(String(core_1.PDFName.of('foobar'))).toBe('/foobar');
        expect(String(core_1.PDFName.of('Lime Green'))).toBe('/Lime#20Green');
        expect(String(core_1.PDFName.of('\0\t\n\f\r '))).toBe('/#00#09#0A#0C#0D#20');
        expect(String(core_1.PDFName.of('Foo#Bar'))).toBe('/Foo#23Bar');
        expect(String(core_1.PDFName.of('paired()parentheses'))).toBe('/paired#28#29parentheses');
        expect(String(core_1.PDFName.of('The_Key_of_F#23_Minor'))).toBe('/The_Key_of_F#23_Minor');
        expect(String(core_1.PDFName.of('A#42'))).toBe('/AB');
    });
    it(`can provide its size in bytes`, () => {
        expect(core_1.PDFName.of('foobar').sizeInBytes()).toBe(7);
        expect(core_1.PDFName.of('Lime Green').sizeInBytes()).toBe(13);
        expect(core_1.PDFName.of('\0\t\n\f\r ').sizeInBytes()).toBe(19);
        expect(core_1.PDFName.of('Foo#Bar').sizeInBytes()).toBe(10);
        expect(core_1.PDFName.of('paired()parentheses').sizeInBytes()).toBe(24);
        expect(core_1.PDFName.of('The_Key_of_F#23_Minor').sizeInBytes()).toBe(22);
        expect(core_1.PDFName.of('A#42').sizeInBytes()).toBe(3);
    });
    it(`can be serialized`, () => {
        const buffer1 = new Uint8Array(23).fill((0, utils_1.toCharCode)(' '));
        expect(core_1.PDFName.of('\0\t\n\f\r ').copyBytesInto(buffer1, 3)).toBe(19);
        expect(buffer1).toEqual((0, utils_1.typedArrayFor)('   /#00#09#0A#0C#0D#20 '));
        const buffer2 = new Uint8Array(17).fill((0, utils_1.toCharCode)(' '));
        expect(core_1.PDFName.of('Lime Green').copyBytesInto(buffer2, 1)).toBe(13);
        expect(buffer2).toEqual((0, utils_1.typedArrayFor)(' /Lime#20Green   '));
        const buffer3 = new Uint8Array(7).fill((0, utils_1.toCharCode)(' '));
        expect(core_1.PDFName.of('A#42').copyBytesInto(buffer3, 4)).toBe(3);
        expect(buffer3).toEqual((0, utils_1.typedArrayFor)('    /AB'));
    });
});
//# sourceMappingURL=PDFName.spec.js.map