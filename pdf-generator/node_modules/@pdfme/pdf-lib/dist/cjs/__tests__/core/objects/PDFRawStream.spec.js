"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("../../../src/core");
const utils_1 = require("../../../src/utils");
describe(`PDFRawStream`, () => {
    const context = core_1.PDFContext.create();
    const dict = core_1.PDFDict.withContext(context);
    const data = new Uint8Array([12, 39, 92, 38, 38, 28, 49]);
    it(`can be constructed from PDFRawStream.of(...)`, () => {
        expect(core_1.PDFRawStream.of(dict, data)).toBeInstanceOf(core_1.PDFRawStream);
    });
    it(`can be converted to a Uint8Array`, () => {
        expect(core_1.PDFRawStream.of(dict, data).asUint8Array()).toEqual(data);
    });
    it(`can be cloned`, () => {
        const original = core_1.PDFRawStream.of(dict, data);
        const clone = original.clone();
        expect(clone).not.toBe(original);
        expect(clone.toString()).toEqual(original.toString());
    });
    it(`can be converted to a string`, () => {
        expect(String(core_1.PDFRawStream.of(dict, data))).toEqual(`<<\n/Length 7\n>>\nstream\n\f'\\&&\u001c1\nendstream`);
    });
    it(`can provide its size in bytes`, () => {
        expect(core_1.PDFRawStream.of(dict, data).sizeInBytes()).toBe(40);
    });
    it(`can be serialized`, () => {
        const buffer = new Uint8Array(44).fill((0, utils_1.toCharCode)(' '));
        expect(core_1.PDFRawStream.of(dict, data).copyBytesInto(buffer, 3));
        expect(buffer).toEqual((0, utils_1.mergeIntoTypedArray)('   <<\n/Length 7\n>>\nstream\n', data, '\nendstream '));
    });
});
//# sourceMappingURL=PDFRawStream.spec.js.map