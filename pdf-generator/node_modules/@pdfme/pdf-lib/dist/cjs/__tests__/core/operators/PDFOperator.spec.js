"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../../src/index");
describe(`PDFOperator`, () => {
    it(`can be constructed with args`, () => {
        const str = index_1.PDFString.of('FooBar');
        expect(index_1.PDFOperator.of(index_1.PDFOperatorNames.ShowText, [str])).toBeInstanceOf(index_1.PDFOperator);
    });
    it(`can be constructed without args`, () => {
        expect(index_1.PDFOperator.of(index_1.PDFOperatorNames.BeginText)).toBeInstanceOf(index_1.PDFOperator);
    });
    it(`can be cloned without args`, () => {
        const original = index_1.PDFOperator.of(index_1.PDFOperatorNames.ClipNonZero);
        const clone = original.clone();
        expect(clone).not.toBe(original);
        expect(String(clone)).toBe(String(original));
    });
    it(`can be cloned with args`, () => {
        const original = index_1.PDFOperator.of(index_1.PDFOperatorNames.MoveText, [
            index_1.PDFNumber.of(25),
            index_1.PDFNumber.of(50),
        ]);
        const clone = original.clone();
        expect(clone).not.toBe(original);
        expect(String(clone)).toBe(String(original));
    });
    it(`can be converted to a string without args`, () => {
        expect(String(index_1.PDFOperator.of(index_1.PDFOperatorNames.ClosePath))).toBe('h');
    });
    it(`can be converted to a string with args`, () => {
        const op = index_1.PDFOperator.of(index_1.PDFOperatorNames.MoveText, [
            index_1.PDFNumber.of(25.43),
            index_1.PDFNumber.of(-50),
        ]);
        expect(String(op)).toBe('25.43 -50 Td');
    });
    it(`can provide its size in bytes without args`, () => {
        expect(index_1.PDFOperator.of(index_1.PDFOperatorNames.ClosePath).sizeInBytes()).toBe(1);
    });
    it(`can provide its size in bytes with args`, () => {
        const op = index_1.PDFOperator.of(index_1.PDFOperatorNames.MoveText, [
            index_1.PDFNumber.of(25.43),
            index_1.PDFNumber.of(-50),
        ]);
        expect(op.sizeInBytes()).toBe(12);
    });
    it(`can be serialized without args`, () => {
        const op = index_1.PDFOperator.of(index_1.PDFOperatorNames.ClosePath);
        const buffer = new Uint8Array(op.sizeInBytes() + 3).fill((0, index_1.toCharCode)(' '));
        expect(op.copyBytesInto(buffer, 2)).toBe(1);
        expect(buffer).toEqual((0, index_1.typedArrayFor)('  h '));
    });
    it(`can be serialized with args`, () => {
        const op = index_1.PDFOperator.of(index_1.PDFOperatorNames.MoveText, [
            index_1.PDFNumber.of(25.43),
            index_1.PDFNumber.of(-50),
        ]);
        const buffer = new Uint8Array(op.sizeInBytes() + 3).fill((0, index_1.toCharCode)(' '));
        expect(op.copyBytesInto(buffer, 2)).toBe(12);
        expect(buffer).toEqual((0, index_1.typedArrayFor)('  25.43 -50 Td '));
    });
});
//# sourceMappingURL=PDFOperator.spec.js.map