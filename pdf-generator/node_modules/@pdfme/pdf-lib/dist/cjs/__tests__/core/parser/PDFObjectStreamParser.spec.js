"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const index_1 = require("../../../src/index");
const readData = (file) => new Uint8Array(fs_1.default.readFileSync(`${__dirname}/data/${file}`));
describe(`PDFObjectStreamParser`, () => {
    it(`parses simple object streams`, () => {
        const context = index_1.PDFContext.create();
        const dict = context.obj({
            N: 3,
            First: 18,
        });
        const contents = readData('object-stream1');
        const stream = index_1.PDFRawStream.of(dict, contents);
        index_1.PDFObjectStreamParser.forStream(stream).parseIntoContext();
        expect(context.enumerateIndirectObjects().length).toBe(3);
    });
    it(`can parse object streams containing the following PDF Object types: [
    PDFDictionary,
    PDFArray
    PDFName,
    PDFString,
    PDFIndirectReference,
    PDFNumber,
    PDFHexString,
    PDFBoolean,
    PDFNull
  ]`, () => {
        const context = index_1.PDFContext.create();
        const dict = context.obj({
            N: 9,
            First: 44,
        });
        const contents = readData('object-stream2');
        const stream = index_1.PDFRawStream.of(dict, contents);
        index_1.PDFObjectStreamParser.forStream(stream).parseIntoContext();
        expect(context.enumerateIndirectObjects().length).toBe(9);
        expect(context.lookup(index_1.PDFRef.of(1))).toBeInstanceOf(index_1.PDFDict);
        expect(context.lookup(index_1.PDFRef.of(2))).toBeInstanceOf(index_1.PDFArray);
        expect(context.lookup(index_1.PDFRef.of(3))).toBe(index_1.PDFName.of('QuxBaz'));
        expect(context.lookup(index_1.PDFRef.of(4))).toBeInstanceOf(index_1.PDFString);
        expect(context.lookup(index_1.PDFRef.of(5))).toBe(index_1.PDFRef.of(21));
        expect(context.lookup(index_1.PDFRef.of(6))).toBeInstanceOf(index_1.PDFNumber);
        expect(context.lookup(index_1.PDFRef.of(7))).toBeInstanceOf(index_1.PDFHexString);
        expect(context.lookup(index_1.PDFRef.of(8))).toBe(index_1.PDFBool.True);
        expect(context.lookup(index_1.PDFRef.of(9))).toBe(index_1.PDFNull);
    });
    it(`handles object streams with newlines separating the integer pairs`, () => {
        const context = index_1.PDFContext.create();
        const dict = context.obj({
            N: 182,
            First: 1786,
        });
        const contents = readData('object-stream3');
        const stream = index_1.PDFRawStream.of(dict, contents);
        index_1.PDFObjectStreamParser.forStream(stream).parseIntoContext();
        expect(context.enumerateIndirectObjects().length).toBe(182);
    });
    it(`handles encoded object streams with PDFName filters`, () => {
        const context = index_1.PDFContext.create();
        const dict = context.obj({
            Filter: 'FlateDecode',
            N: 115,
            First: 924,
        });
        const contents = readData('object-stream4');
        const stream = index_1.PDFRawStream.of(dict, contents);
        index_1.PDFObjectStreamParser.forStream(stream).parseIntoContext();
        expect(context.enumerateIndirectObjects().length).toBe(115);
    });
    it(`handles encoded object streams with PDFArray filters`, () => {
        const context = index_1.PDFContext.create();
        const dict = context.obj({
            Filter: ['FlateDecode'],
            N: 115,
            First: 924,
        });
        const contents = readData('object-stream4');
        const stream = index_1.PDFRawStream.of(dict, contents);
        index_1.PDFObjectStreamParser.forStream(stream).parseIntoContext();
        expect(context.enumerateIndirectObjects().length).toBe(115);
    });
    it(`throws an error for invalid Filters`, () => {
        const context = index_1.PDFContext.create();
        const dict = context.obj({
            Filter: 42,
            N: 115,
            First: 924,
        });
        const contents = readData('object-stream4');
        const stream = index_1.PDFRawStream.of(dict, contents);
        expect(() => index_1.PDFObjectStreamParser.forStream(stream).parseIntoContext()).toThrow();
    });
    it(`throws an error for invalid object streams`, async () => {
        const context = index_1.PDFContext.create();
        const dict = context.obj({
            N: 1,
            First: 5,
        });
        const contents = readData('object-stream-invalid');
        const stream = index_1.PDFRawStream.of(dict, contents);
        await expect(index_1.PDFObjectStreamParser.forStream(stream).parseIntoContext()).rejects.toThrow();
    });
    it(`prevents reparsing`, async () => {
        const context = index_1.PDFContext.create();
        const dict = context.obj({
            N: 3,
            First: 18,
        });
        const contents = readData('object-stream1');
        const stream = index_1.PDFRawStream.of(dict, contents);
        const parser = index_1.PDFObjectStreamParser.forStream(stream);
        await expect(parser.parseIntoContext()).resolves.not.toThrow();
        await expect(parser.parseIntoContext()).rejects.toThrow(new index_1.ReparseError('PDFObjectStreamParser', 'parseIntoContext'));
    });
});
//# sourceMappingURL=PDFObjectStreamParser.spec.js.map