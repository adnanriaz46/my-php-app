"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../src/index");
describe(`PDFObjectCopier`, () => {
    it(`copies PDFDicts, including their indirect references`, () => {
        // Arrange
        const src = index_1.PDFContext.create();
        const origDict = src.obj({
            Foo: index_1.PDFString.of('stuff and things'),
            Bar: index_1.PDFRef.of(13),
        });
        src.register(origDict);
        src.assign(index_1.PDFRef.of(13), src.obj([1, index_1.PDFRef.of(17)]));
        src.assign(index_1.PDFRef.of(17), src.obj({ Baz: 'wallykazam' }));
        const dest = index_1.PDFContext.create();
        // Act
        const copiedDict = index_1.PDFObjectCopier.for(src, dest).copy(origDict);
        // Assert
        expect(dest.enumerateIndirectObjects().length).toBe(2);
        expect(copiedDict).not.toBe(origDict);
        expect(copiedDict).toBeInstanceOf(index_1.PDFDict);
        const Foo = index_1.PDFName.of('Foo');
        expect(copiedDict.get(Foo)).not.toBe(origDict.get(Foo));
        expect(copiedDict.get(Foo)).toBeInstanceOf(index_1.PDFString);
        const Bar = index_1.PDFName.of('Bar');
        expect(copiedDict.get(Bar)).not.toBe(origDict.get(Bar));
        expect(copiedDict.get(Bar)).toBeInstanceOf(index_1.PDFRef);
        const srcBar = src.lookup(origDict.get(Bar), index_1.PDFArray);
        const destBar = dest.lookup(copiedDict.get(Bar), index_1.PDFArray);
        expect(destBar).not.toBe(srcBar);
        expect(destBar).toBeInstanceOf(index_1.PDFArray);
        expect(destBar.get(0)).not.toBe(srcBar.get(0));
        expect(destBar.get(0)).toBeInstanceOf(index_1.PDFNumber);
        expect(destBar.get(1)).not.toBe(srcBar.get(1));
        expect(destBar.get(1)).toBeInstanceOf(index_1.PDFRef);
        const srcBar1 = src.lookup(srcBar.get(1), index_1.PDFDict);
        const destBar1 = dest.lookup(destBar.get(1), index_1.PDFDict);
        expect(destBar1).not.toBe(srcBar1);
        expect(destBar1).toBeInstanceOf(index_1.PDFDict);
        const Baz = index_1.PDFName.of('Baz');
        expect(destBar1.get(Baz)).toBe(srcBar1.get(Baz));
        expect(destBar1.get(Baz)).toBeInstanceOf(index_1.PDFName);
    });
    it(`copies PDFArrays, including their indirect references`, () => {
        // Arrange
        const src = index_1.PDFContext.create();
        const origArray = src.obj([
            index_1.PDFString.of('stuff and things'),
            index_1.PDFRef.of(13),
        ]);
        src.register(origArray);
        src.assign(index_1.PDFRef.of(13), src.obj({ Foo: 1, Bar: index_1.PDFRef.of(17) }));
        src.assign(index_1.PDFRef.of(17), src.obj(['wallykazam']));
        const dest = index_1.PDFContext.create();
        // Act
        const copiedArray = index_1.PDFObjectCopier.for(src, dest).copy(origArray);
        // Assert
        expect(dest.enumerateIndirectObjects().length).toBe(2);
        expect(copiedArray).not.toBe(origArray);
        expect(copiedArray).toBeInstanceOf(index_1.PDFArray);
        expect(copiedArray.get(0)).not.toBe(origArray.get(0));
        expect(copiedArray.get(0)).toBeInstanceOf(index_1.PDFString);
        expect(copiedArray.get(1)).not.toBe(origArray.get(1));
        expect(copiedArray.get(1)).toBeInstanceOf(index_1.PDFRef);
        const src1 = src.lookup(origArray.get(1), index_1.PDFDict);
        const dest1 = dest.lookup(copiedArray.get(1), index_1.PDFDict);
        expect(dest1).not.toBe(src1);
        expect(dest1).toBeInstanceOf(index_1.PDFDict);
        const Foo = index_1.PDFName.of('Foo');
        expect(dest1.get(Foo)).not.toBe(src1.get(Foo));
        expect(dest1.get(Foo)).toBeInstanceOf(index_1.PDFNumber);
        const Bar = index_1.PDFName.of('Bar');
        expect(dest1.get(Bar)).not.toBe(src1.get(Bar));
        expect(dest1.get(Bar)).toBeInstanceOf(index_1.PDFRef);
        const src1Bar = src.lookup(src1.get(Bar), index_1.PDFArray);
        const dest1Bar = dest.lookup(dest1.get(Bar), index_1.PDFArray);
        expect(dest1Bar).not.toBe(src1Bar);
        expect(dest1Bar).toBeInstanceOf(index_1.PDFArray);
        expect(dest1Bar.get(0)).toBe(src1Bar.get(0));
        expect(dest1Bar.get(0)).toBeInstanceOf(index_1.PDFName);
    });
    it(`copies PDFStreams, including their indirect references`, () => {
        // Arrange
        const src = index_1.PDFContext.create();
        const origStream = src.stream(new Uint8Array([1, 2, 3, 4, 5]), {
            Foo: index_1.PDFString.of('stuff and things'),
            Bar: index_1.PDFRef.of(13),
        });
        src.register(origStream);
        src.assign(index_1.PDFRef.of(13), src.obj([1, index_1.PDFRef.of(17)]));
        src.assign(index_1.PDFRef.of(17), src.obj({ Baz: 'wallykazam' }));
        const dest = index_1.PDFContext.create();
        // Act
        const copiedStream = index_1.PDFObjectCopier.for(src, dest).copy(origStream);
        // Assert
        expect(dest.enumerateIndirectObjects().length).toBe(2);
        expect(copiedStream).not.toBe(origStream);
        expect(copiedStream).toBeInstanceOf(index_1.PDFRawStream);
        expect(copiedStream.contents).not.toBe(origStream.contents);
        expect(copiedStream.contents).toEqual(origStream.contents);
        const Foo = index_1.PDFName.of('Foo');
        expect(copiedStream.dict.get(Foo)).not.toBe(origStream.dict.get(Foo));
        expect(copiedStream.dict.get(Foo)).toBeInstanceOf(index_1.PDFString);
        const Bar = index_1.PDFName.of('Bar');
        expect(copiedStream.dict.get(Bar)).not.toBe(origStream.dict.get(Bar));
        expect(copiedStream.dict.get(Bar)).toBeInstanceOf(index_1.PDFRef);
        const srcBar = src.lookup(origStream.dict.get(Bar), index_1.PDFArray);
        const destBar = dest.lookup(copiedStream.dict.get(Bar), index_1.PDFArray);
        expect(destBar).not.toBe(srcBar);
        expect(destBar).toBeInstanceOf(index_1.PDFArray);
        expect(destBar.get(0)).not.toBe(srcBar.get(0));
        expect(destBar.get(0)).toBeInstanceOf(index_1.PDFNumber);
        expect(destBar.get(1)).not.toBe(srcBar.get(1));
        expect(destBar.get(1)).toBeInstanceOf(index_1.PDFRef);
        const srcBar1 = src.lookup(srcBar.get(1), index_1.PDFDict);
        const destBar1 = dest.lookup(destBar.get(1), index_1.PDFDict);
        expect(destBar1).not.toBe(srcBar1);
        expect(destBar1).toBeInstanceOf(index_1.PDFDict);
        const Baz = index_1.PDFName.of('Baz');
        expect(destBar1.get(Baz)).toBe(srcBar1.get(Baz));
        expect(destBar1.get(Baz)).toBeInstanceOf(index_1.PDFName);
    });
    it(`copies PDFRefs, including their indirect references`, () => {
        // Arrange
        const src = index_1.PDFContext.create();
        const origRef = index_1.PDFRef.of(21);
        src.assign(origRef, src.obj({ Foo: index_1.PDFString.of('stuff and things'), Bar: index_1.PDFRef.of(13) }));
        src.assign(index_1.PDFRef.of(13), src.obj([1, index_1.PDFRef.of(17)]));
        src.assign(index_1.PDFRef.of(17), src.obj({ Baz: 'wallykazam' }));
        const dest = index_1.PDFContext.create();
        // Act
        const copiedRef = index_1.PDFObjectCopier.for(src, dest).copy(origRef);
        // Assert
        expect(dest.enumerateIndirectObjects().length).toBe(3);
        expect(copiedRef).not.toBe(origRef);
        expect(copiedRef).toBeInstanceOf(index_1.PDFRef);
        const origDeref = src.lookup(origRef, index_1.PDFDict);
        const copiedDeref = dest.lookup(copiedRef, index_1.PDFDict);
        const Foo = index_1.PDFName.of('Foo');
        expect(copiedDeref.get(Foo)).not.toBe(origDeref.get(Foo));
        expect(copiedDeref.get(Foo)).toBeInstanceOf(index_1.PDFString);
        const Bar = index_1.PDFName.of('Bar');
        expect(copiedDeref.get(Bar)).not.toBe(origDeref.get(Bar));
        expect(copiedDeref.get(Bar)).toBeInstanceOf(index_1.PDFRef);
        const srcBar = src.lookup(origDeref.get(Bar), index_1.PDFArray);
        const destBar = dest.lookup(copiedDeref.get(Bar), index_1.PDFArray);
        expect(destBar).not.toBe(srcBar);
        expect(destBar).toBeInstanceOf(index_1.PDFArray);
        expect(destBar.get(0)).not.toBe(srcBar.get(0));
        expect(destBar.get(0)).toBeInstanceOf(index_1.PDFNumber);
        expect(destBar.get(1)).not.toBe(srcBar.get(1));
        expect(destBar.get(1)).toBeInstanceOf(index_1.PDFRef);
        const srcBar1 = src.lookup(srcBar.get(1), index_1.PDFDict);
        const destBar1 = dest.lookup(destBar.get(1), index_1.PDFDict);
        expect(destBar1).not.toBe(srcBar1);
        expect(destBar1).toBeInstanceOf(index_1.PDFDict);
        const Baz = index_1.PDFName.of('Baz');
        expect(destBar1.get(Baz)).toBe(srcBar1.get(Baz));
        expect(destBar1.get(Baz)).toBeInstanceOf(index_1.PDFName);
    });
    it(`copies individual PDFPageLeaf objects, without bringing along the whole page tree`, () => {
        // Arrange
        const src = index_1.PDFContext.create();
        const contentStreamRef = index_1.PDFRef.of(21);
        const origPageRef = src.nextRef();
        const middlePageTreeRef = src.nextRef();
        const rootPageTreeRef = src.nextRef();
        const contentStream = index_1.PDFContentStream.of(src.obj({}), []);
        const origPage = index_1.PDFPageLeaf.withContextAndParent(src, middlePageTreeRef);
        origPage.set(index_1.PDFName.of('Contents'), src.obj([contentStreamRef]));
        const middlePageTree = index_1.PDFPageTree.withContext(src, rootPageTreeRef);
        const rectangle = src.obj([1, 2, 3, 4]);
        const rootPageTree = index_1.PDFPageTree.withContext(src);
        rootPageTree.set(index_1.PDFName.of('Resources'), src.obj({}));
        rootPageTree.set(index_1.PDFName.of('MediaBox'), rectangle);
        rootPageTree.set(index_1.PDFName.of('CropBox'), rectangle);
        rootPageTree.set(index_1.PDFName.of('Rotate'), index_1.PDFNumber.of(180));
        rootPageTree.pushTreeNode(middlePageTreeRef);
        middlePageTree.pushLeafNode(origPageRef);
        src.assign(contentStreamRef, contentStream);
        src.assign(origPageRef, origPage);
        src.assign(middlePageTreeRef, middlePageTree);
        src.assign(rootPageTreeRef, rootPageTree);
        const dest = index_1.PDFContext.create();
        // Act
        const copiedPage = index_1.PDFObjectCopier.for(src, dest).copy(origPage);
        // Assert
        expect(dest.enumerateIndirectObjects().length).toBe(1);
        expect(copiedPage).not.toBe(origPage);
        expect(copiedPage).toBeInstanceOf(index_1.PDFPageLeaf);
        const Contents = copiedPage.Contents();
        expect(Contents).not.toBe(origPage.Contents());
        expect(Contents).toBeInstanceOf(index_1.PDFArray);
        expect(Contents.size()).toBe(1);
        expect(Contents.get(0)).not.toBe(origPage.Contents().get(0));
        expect(Contents.get(0)).toBeInstanceOf(index_1.PDFRef);
        const Resources = copiedPage.Resources();
        expect(Resources).not.toBe(rootPageTree.get(index_1.PDFName.of('Resources')));
        expect(Resources).toBeInstanceOf(index_1.PDFDict);
        const MediaBox = copiedPage.MediaBox();
        expect(MediaBox).not.toBe(rootPageTree.get(index_1.PDFName.of('MediaBox')));
        expect(MediaBox).toBeInstanceOf(index_1.PDFArray);
        const CropBox = copiedPage.CropBox();
        expect(CropBox).not.toBe(rootPageTree.get(index_1.PDFName.of('CropBox')));
        expect(CropBox).toBeInstanceOf(index_1.PDFArray);
        const Rotate = copiedPage.Rotate();
        expect(Rotate).not.toBe(rootPageTree.get(index_1.PDFName.of('Rotate')));
        expect(Rotate).toBeInstanceOf(index_1.PDFNumber);
    });
    it(`copies objects with cyclic references`, () => {
        // Arrange
        const src = index_1.PDFContext.create();
        const dictRef = src.nextRef();
        const arrayRef = src.nextRef();
        const dict = src.obj({ Foo: arrayRef, Bar: dictRef });
        const array = src.obj([dictRef, arrayRef]);
        src.assign(dictRef, dict);
        src.assign(arrayRef, array);
        const dest = index_1.PDFContext.create();
        // Act
        index_1.PDFObjectCopier.for(src, dest).copy(dict);
        // Assert
        expect(dest.enumerateIndirectObjects().length).toBe(src.enumerateIndirectObjects().length);
    });
    it(`copies all types of PDFObjects`, () => {
        // Arrange
        const src = index_1.PDFContext.create();
        const dest = index_1.PDFContext.create();
        const copier = index_1.PDFObjectCopier.for(src, dest);
        const origArray = src.obj([]);
        const origBool = src.obj(true);
        const origDict = src.obj({});
        const origHexString = index_1.PDFHexString.of('ABC123');
        const origIndirectRef = src.register(origBool);
        const origName = src.obj('QuxBaz');
        const origNull = src.obj(null);
        const origNumber = src.obj(21);
        const origRawStream = src.stream(new Uint8Array([1, 2]));
        const origString = index_1.PDFString.of('Stuff and thingz');
        // Act
        const copiedArray = copier.copy(origArray);
        const copiedBool = copier.copy(origBool);
        const copiedDict = copier.copy(origDict);
        const copiedHexString = copier.copy(origHexString);
        const copiedIndirectRef = copier.copy(origIndirectRef);
        const copiedName = copier.copy(origName);
        const copiedNull = copier.copy(origNull);
        const copiedNumber = copier.copy(origNumber);
        const copiedRawStream = copier.copy(origRawStream);
        const copiedString = copier.copy(origString);
        // Assert
        expect(copiedArray).not.toBe(origArray);
        expect(copiedArray).toBeInstanceOf(index_1.PDFArray);
        expect(copiedBool).toBe(origBool);
        expect(copiedBool).toBeInstanceOf(index_1.PDFBool);
        expect(copiedDict).not.toBe(origDict);
        expect(copiedDict).toBeInstanceOf(index_1.PDFDict);
        expect(copiedHexString).not.toBe(origHexString);
        expect(copiedHexString).toBeInstanceOf(index_1.PDFHexString);
        expect(copiedIndirectRef).toBe(origIndirectRef);
        expect(copiedIndirectRef).toBeInstanceOf(index_1.PDFRef);
        expect(copiedName).toBe(origName);
        expect(copiedName).toBeInstanceOf(index_1.PDFName);
        expect(copiedNull).toBe(origNull);
        expect(copiedNull).toBe(index_1.PDFNull);
        expect(copiedNumber).not.toBe(origNumber);
        expect(copiedNumber).toBeInstanceOf(index_1.PDFNumber);
        expect(copiedRawStream).not.toBe(origRawStream);
        expect(copiedRawStream).toBeInstanceOf(index_1.PDFRawStream);
        expect(copiedString).not.toBe(origString);
        expect(copiedString).toBeInstanceOf(index_1.PDFString);
    });
    it(`copies objects with undefined references`, () => {
        // Arrange
        const src = index_1.PDFContext.create();
        const dest = index_1.PDFContext.create();
        const copier = index_1.PDFObjectCopier.for(src, dest);
        const origArray = src.obj([index_1.PDFRef.of(21)]);
        const origDict = src.obj({ Foo: index_1.PDFRef.of(21) });
        // Act
        const copiedArray = copier.copy(origArray);
        const copiedDict = copier.copy(origDict);
        // Assert
        expect(copiedArray).not.toBe(origArray);
        expect(copiedArray).toBeInstanceOf(index_1.PDFArray);
        expect(copiedArray.size()).toBe(1);
        expect(copiedArray.get(0)).toBe(index_1.PDFRef.of(1));
        expect(copiedDict).not.toBe(origDict);
        expect(copiedDict).toBeInstanceOf(index_1.PDFDict);
        expect(copiedDict.entries().length).toBe(1);
        expect(copiedDict.get(index_1.PDFName.of('Foo'))).toBe(index_1.PDFRef.of(1));
    });
});
//# sourceMappingURL=PDFObjectCopier.spec.js.map