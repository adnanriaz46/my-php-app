"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const standard_fonts_1 = require("@pdf-lib/standard-fonts");
const index_1 = require("../../../src/index");
describe(`StandardFontEmbedder`, () => {
    it(`can be constructed with StandardFontEmbedder.for(...)`, () => {
        const embedder = index_1.StandardFontEmbedder.for(standard_fonts_1.FontNames.Helvetica);
        expect(embedder).toBeInstanceOf(index_1.StandardFontEmbedder);
    });
    it(`exposes the font's name`, () => {
        const embedder = index_1.StandardFontEmbedder.for(standard_fonts_1.FontNames.HelveticaOblique);
        expect(embedder.fontName).toBe('Helvetica-Oblique');
    });
    it(`can use a custom font name`, () => {
        const customName = 'Roboto 2';
        const embedder = index_1.StandardFontEmbedder.for(standard_fonts_1.FontNames.HelveticaOblique, customName);
        expect(embedder.customName).toBe(customName);
    });
    it(`can embed standard font dictionaries into PDFContexts without a predefined ref`, () => {
        const context = index_1.PDFContext.create();
        const embedder = index_1.StandardFontEmbedder.for(standard_fonts_1.FontNames.Courier);
        expect(context.enumerateIndirectObjects().length).toBe(0);
        const ref = embedder.embedIntoContext(context);
        expect(context.enumerateIndirectObjects().length).toBe(1);
        expect(context.lookup(ref)).toBeInstanceOf(index_1.PDFDict);
    });
    it(`can embed standard font dictionaries into PDFContexts with a predefined ref`, () => {
        const context = index_1.PDFContext.create();
        const predefinedRef = index_1.PDFRef.of(9999);
        const embedder = index_1.StandardFontEmbedder.for(standard_fonts_1.FontNames.Courier);
        expect(context.enumerateIndirectObjects().length).toBe(0);
        const ref = embedder.embedIntoContext(context, predefinedRef);
        expect(context.enumerateIndirectObjects().length).toBe(1);
        expect(context.lookup(predefinedRef)).toBeInstanceOf(index_1.PDFDict);
        expect(ref).toBe(predefinedRef);
    });
    it(`can encode text strings into PDFHexString objects`, () => {
        const text = 'Stuff and thingz!';
        const embedder = index_1.StandardFontEmbedder.for(standard_fonts_1.FontNames.TimesRoman);
        expect(embedder.encodeText(text)).toBeInstanceOf(index_1.PDFHexString);
        expect(String(embedder.encodeText(text))).toBe(String(index_1.PDFHexString.of('537475666620616E64207468696E677A21')));
    });
    it(`can measure the width of text strings at the given font size`, () => {
        const text = 'Stuff and thingz!';
        const embedder = index_1.StandardFontEmbedder.for(standard_fonts_1.FontNames.HelveticaBold);
        expect(embedder.widthOfTextAtSize(text, 12)).toBe(94.656);
        expect(embedder.widthOfTextAtSize(text, 24)).toBe(189.312);
    });
    it(`can measure the height of the font at the given size`, () => {
        const embedder = index_1.StandardFontEmbedder.for(standard_fonts_1.FontNames.HelveticaBold);
        expect(embedder.heightOfFontAtSize(12)).toBeCloseTo(11.1);
        expect(embedder.heightOfFontAtSize(24)).toBeCloseTo(22.2);
    });
    it(`can measure the size of the font at a given height`, () => {
        const embedder = index_1.StandardFontEmbedder.for(standard_fonts_1.FontNames.HelveticaBold);
        expect(embedder.sizeOfFontAtHeight(12)).toBeCloseTo(12.972);
        expect(embedder.sizeOfFontAtHeight(24)).toBeCloseTo(25.945);
    });
});
//# sourceMappingURL=StandardFontEmbedder.spec.js.map