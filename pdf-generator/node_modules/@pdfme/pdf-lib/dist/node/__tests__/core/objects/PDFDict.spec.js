"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("../../../src/core");
const utils_1 = require("../../../src/utils");
describe(`PDFDict`, () => {
    const context = core_1.PDFContext.create();
    it(`can be constructed from PDFDict.withContext(...)`, () => {
        expect(core_1.PDFDict.withContext(context)).toBeInstanceOf(core_1.PDFDict);
    });
    const pdfDict = core_1.PDFDict.withContext(context);
    const pdfBool = core_1.PDFBool.True;
    const pdfHexString = core_1.PDFHexString.of('ABC123');
    const pdfName = core_1.PDFName.of('Foo#Bar!');
    const pdfNull = core_1.PDFNull;
    const pdfNumber = core_1.PDFNumber.of(-24.179);
    const pdfString = core_1.PDFString.of('foobar');
    const pdfRef = core_1.PDFRef.of(21, 92);
    pdfDict.set(core_1.PDFName.of('Boolean'), pdfBool);
    pdfDict.set(core_1.PDFName.of('HexString'), pdfHexString);
    pdfDict.set(core_1.PDFName.of('Name'), pdfName);
    pdfDict.set(core_1.PDFName.of('Null'), pdfNull);
    pdfDict.set(core_1.PDFName.of('Number'), pdfNumber);
    pdfDict.set(core_1.PDFName.of('String'), pdfString);
    pdfDict.set(core_1.PDFName.of('Ref'), pdfRef);
    const pdfArray = core_1.PDFArray.withContext(context);
    pdfArray.push(core_1.PDFBool.True);
    pdfArray.push(core_1.PDFNull);
    const pdfSubDict = core_1.PDFDict.withContext(context);
    pdfSubDict.set(core_1.PDFName.of('Array'), pdfArray);
    pdfDict.set(core_1.PDFName.of('Dictionary'), pdfSubDict);
    it(`can detect if a value is present`, () => {
        expect(pdfDict.has(core_1.PDFName.of('Boolean'))).toBe(true);
        expect(pdfDict.has(core_1.PDFName.of('HexString'))).toBe(true);
        expect(pdfDict.has(core_1.PDFName.of('Name'))).toBe(true);
        expect(pdfDict.has(core_1.PDFName.of('Null'))).toBe(false);
        expect(pdfDict.has(core_1.PDFName.of('Number'))).toBe(true);
        expect(pdfDict.has(core_1.PDFName.of('String'))).toBe(true);
        expect(pdfDict.has(core_1.PDFName.of('Ref'))).toBe(true);
        expect(pdfDict.has(core_1.PDFName.of('Dictionary'))).toBe(true);
        expect(pdfSubDict.has(core_1.PDFName.of('Array'))).toBe(true);
        expect(pdfDict.has(core_1.PDFName.of('foo'))).toBe(false);
    });
    it(`retains entered objects`, () => {
        expect(pdfDict.entries().length).toBe(8);
        expect(pdfDict.get(core_1.PDFName.of('Boolean'))).toBe(pdfBool);
        expect(pdfDict.get(core_1.PDFName.of('HexString'))).toBe(pdfHexString);
        expect(pdfDict.get(core_1.PDFName.of('Name'))).toBe(pdfName);
        expect(pdfDict.get(core_1.PDFName.of('Null'))).toBe(undefined);
        expect(pdfDict.get(core_1.PDFName.of('Number'))).toBe(pdfNumber);
        expect(pdfDict.get(core_1.PDFName.of('String'))).toBe(pdfString);
        expect(pdfDict.get(core_1.PDFName.of('Ref'))).toBe(pdfRef);
        expect(pdfDict.get(core_1.PDFName.of('Dictionary'))).toBe(pdfSubDict);
        expect(pdfSubDict.get(core_1.PDFName.of('Array'))).toBe(pdfArray);
    });
    it(`can be converted to a Map`, () => {
        expect(pdfDict.asMap()).toEqual(new Map([
            [core_1.PDFName.of('Boolean'), pdfBool],
            [core_1.PDFName.of('HexString'), pdfHexString],
            [core_1.PDFName.of('Name'), pdfName],
            [core_1.PDFName.of('Null'), pdfNull],
            [core_1.PDFName.of('Number'), pdfNumber],
            [core_1.PDFName.of('String'), pdfString],
            [core_1.PDFName.of('Ref'), pdfRef],
            [core_1.PDFName.of('Dictionary'), pdfSubDict],
        ]));
    });
    it(`can be cloned`, () => {
        const original = pdfDict;
        const clone = original.clone();
        expect(clone).not.toBe(original);
        expect(clone.toString()).toBe(original.toString());
    });
    it(`can be converted to a string`, () => {
        expect(String(pdfDict)).toBe(`<<
/Boolean true
/HexString <ABC123>
/Name /Foo#23Bar!
/Null null
/Number -24.179
/String (foobar)
/Ref 21 92 R
/Dictionary <<
/Array [ true null ]
>>
>>`);
    });
    it(`can provide its size in bytes`, () => {
        expect(pdfDict.sizeInBytes()).toBe(153);
    });
    it(`can be serialized`, () => {
        const buffer = new Uint8Array(157).fill((0, utils_1.toCharCode)(' '));
        expect(pdfDict.copyBytesInto(buffer, 3)).toBe(153);
        expect(buffer).toEqual((0, utils_1.typedArrayFor)(`   <<
/Boolean true
/HexString <ABC123>
/Name /Foo#23Bar!
/Null null
/Number -24.179
/String (foobar)
/Ref 21 92 R
/Dictionary <<
/Array [ true null ]
>>
>> `));
    });
    it(`returns "undefined" if the underlying value is "PDFNull"`, () => {
        const dict = context.obj({ foo: null });
        dict.set(core_1.PDFName.of('Bar'), core_1.PDFNull);
        context.assign(core_1.PDFRef.of(21), core_1.PDFNull);
        dict.set(core_1.PDFName.of('qux'), core_1.PDFRef.of(21));
        expect(dict.get(core_1.PDFName.of('foo'))).toBe(undefined);
        expect(dict.get(core_1.PDFName.of('Bar'))).toBe(undefined);
        expect(dict.get(core_1.PDFName.of('qux'))).toBe(core_1.PDFRef.of(21));
        expect(dict.lookup(core_1.PDFName.of('foo'))).toBe(undefined);
        expect(dict.lookup(core_1.PDFName.of('Bar'))).toBe(undefined);
        expect(dict.lookup(core_1.PDFName.of('qux'))).toBe(undefined);
        expect(dict.lookup(core_1.PDFName.of('foo'), core_1.PDFNull)).toBe(core_1.PDFNull);
        expect(dict.lookup(core_1.PDFName.of('Bar'), core_1.PDFNull)).toBe(core_1.PDFNull);
        expect(dict.lookup(core_1.PDFName.of('qux'), core_1.PDFNull)).toBe(core_1.PDFNull);
        expect(dict.lookupMaybe(core_1.PDFName.of('foo'), core_1.PDFNull)).toBe(core_1.PDFNull);
        expect(dict.lookupMaybe(core_1.PDFName.of('Bar'), core_1.PDFNull)).toBe(core_1.PDFNull);
        expect(dict.lookupMaybe(core_1.PDFName.of('qux'), core_1.PDFNull)).toBe(core_1.PDFNull);
        expect(dict.lookupMaybe(core_1.PDFName.of('foo'), core_1.PDFDict)).toBe(undefined);
        expect(dict.lookupMaybe(core_1.PDFName.of('Bar'), core_1.PDFDict)).toBe(undefined);
        expect(dict.lookupMaybe(core_1.PDFName.of('qux'), core_1.PDFDict)).toBe(undefined);
    });
    // https://github.com/Hopding/pdf-lib/issues/1075
    it(`can generate new keys that don't conflict with existing ones`, () => {
        const anotherContext = core_1.PDFContext.create();
        const anotherDict = anotherContext.obj({});
        const anotherKey = anotherDict.uniqueKey();
        const dict = context.obj({});
        expect(dict.keys().length).toBe(0);
        dict.set(anotherKey, context.obj('boing'));
        expect(dict.keys().length).toBe(1);
        const key1 = dict.uniqueKey();
        dict.set(key1, context.obj('beep'));
        expect(dict.keys().length).toBe(2);
        const key2 = dict.uniqueKey();
        dict.set(key2, context.obj('boop'));
        expect(dict.keys().length).toBe(3);
        const key3 = dict.uniqueKey();
        dict.set(key3, context.obj('baap'));
        expect(dict.keys().length).toBe(4);
        expect(new Set(dict.keys()).size).toBe(4);
        expect(dict.keys()).toEqual([anotherKey, key1, key2, key3]);
    });
});
//# sourceMappingURL=PDFDict.spec.js.map