"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("../../../src/core");
const utils_1 = require("../../../src/utils");
describe(`PDFString`, () => {
    it(`can be constructed from PDFString.of(...)`, () => {
        expect(core_1.PDFString.of('foobar')).toBeInstanceOf(core_1.PDFString);
        expect(core_1.PDFString.of(' (foo(bar))')).toBeInstanceOf(core_1.PDFString);
        expect(core_1.PDFString.of(')b\\a/z(')).toBeInstanceOf(core_1.PDFString);
    });
    it(`can be constructed from a Date object`, () => {
        const date1 = new Date('2018-06-24T01:58:37.228Z');
        expect(String(core_1.PDFString.fromDate(date1))).toBe('(D:20180624015837Z)');
        const date2 = new Date('2019-12-21T07:00:11.000Z');
        expect(String(core_1.PDFString.fromDate(date2))).toBe('(D:20191221070011Z)');
    });
    it(`can be converted to a string`, () => {
        expect(core_1.PDFString.of('foobar').asString()).toBe('foobar');
        const date = new Date('2018-06-24T01:58:37.228Z');
        expect(core_1.PDFString.fromDate(date).asString()).toBe('D:20180624015837Z');
    });
    it(`can be cloned`, () => {
        const original = core_1.PDFString.of(')b\\a/z(');
        const clone = original.clone();
        expect(clone).not.toBe(original);
        expect(clone.toString()).toBe(original.toString());
    });
    describe(`conversion to string`, () => {
        it(`can be converted to a string`, () => {
            expect(String(core_1.PDFString.of('foobar'))).toBe('(foobar)');
        });
        it(`does not escape backslashes`, () => {
            expect(String(core_1.PDFString.of('Foo\\Bar\\Qux'))).toBe('(Foo\\Bar\\Qux)');
        });
        it(`does not escape nested parenthesis`, () => {
            expect(String(core_1.PDFString.of('(Foo((Bar))Qux)'))).toBe('((Foo((Bar))Qux))');
        });
    });
    describe(`converting to bytes`, () => {
        it(`can interpret escaped octal codes`, () => {
            const literal = '\\376\\377\\000\\105\\000\\147\\000\\147\\000\\040\\330\\074\\337\\163';
            // prettier-ignore
            expect(core_1.PDFString.of(literal).asBytes()).toEqual(Uint8Array.of(0o376, 0o377, 0o000, 0o105, 0o000, 0o147, 0o000, 0o147, 0o000, 0o040, 0o330, 0o074, 0o337, 0o163));
        });
        it(`can interpret ASCII symbols`, () => {
            const literal = '\\376\\377\0E\0g\0g\0 \\330<\\337s';
            // prettier-ignore
            expect(core_1.PDFString.of(literal).asBytes()).toEqual(Uint8Array.of(0o376, 0o377, (0, utils_1.toCharCode)('\0'), (0, utils_1.toCharCode)('E'), (0, utils_1.toCharCode)('\0'), (0, utils_1.toCharCode)('g'), (0, utils_1.toCharCode)('\0'), (0, utils_1.toCharCode)('g'), (0, utils_1.toCharCode)('\0'), (0, utils_1.toCharCode)(' '), 0o330, (0, utils_1.toCharCode)('<'), 0o337, (0, utils_1.toCharCode)('s')));
        });
        it(`can ignore line breaks`, () => {
            const literal = '\\376\\377\0E\\\n\\0g\0g\0 \\330<\\337s';
            // prettier-ignore
            expect(core_1.PDFString.of(literal).asBytes()).toEqual(Uint8Array.of(0o376, 0o377, (0, utils_1.toCharCode)('\0'), (0, utils_1.toCharCode)('E'), (0, utils_1.toCharCode)('\0'), (0, utils_1.toCharCode)('g'), (0, utils_1.toCharCode)('\0'), (0, utils_1.toCharCode)('g'), (0, utils_1.toCharCode)('\0'), (0, utils_1.toCharCode)(' '), 0o330, (0, utils_1.toCharCode)('<'), 0o337, (0, utils_1.toCharCode)('s')));
        });
        it(`can interpret EOLs and line breaks`, () => {
            const literal = 'a\nb\rc\\\nd\\\re';
            // prettier-ignore
            expect(core_1.PDFString.of(literal).asBytes()).toEqual(Uint8Array.of((0, utils_1.toCharCode)('a'), (0, utils_1.toCharCode)('\n'), (0, utils_1.toCharCode)('b'), (0, utils_1.toCharCode)('\r'), (0, utils_1.toCharCode)('c'), (0, utils_1.toCharCode)('d'), (0, utils_1.toCharCode)('e')));
        });
        it(`can interpret invalid escapes`, () => {
            const literal = 'a\nb\rc\\xd\\;';
            // prettier-ignore
            expect(core_1.PDFString.of(literal).asBytes()).toEqual(Uint8Array.of((0, utils_1.toCharCode)('a'), (0, utils_1.toCharCode)('\n'), (0, utils_1.toCharCode)('b'), (0, utils_1.toCharCode)('\r'), (0, utils_1.toCharCode)('c'), (0, utils_1.toCharCode)('x'), (0, utils_1.toCharCode)('d'), (0, utils_1.toCharCode)(';')));
        });
    });
    describe(`decoding to string`, () => {
        it(`can interpret UTF-16BE strings with escaped octal codes`, () => {
            const literal = '\\376\\377\\000\\105\\000\\147\\000\\147\\000\\040\\330\\074\\337\\163';
            expect(core_1.PDFString.of(literal).decodeText()).toBe('Egg 🍳');
        });
        it(`can interpret UTF-16BE strings with ASCII symbols`, () => {
            const literal = '\\376\\377\0E\0g\0g\0 \\330<\\337s';
            expect(core_1.PDFString.of(literal).decodeText()).toBe('Egg 🍳');
        });
        it(`can interpret UTF-16BE strings with line breaks`, () => {
            const literal = '\\376\\377\0E\\\n\\0g\0g\0 \\330<\\337s';
            expect(core_1.PDFString.of(literal).decodeText()).toBe('Egg 🍳');
        });
        it(`can interpret UTF-16LE strings with escaped octal codes`, () => {
            const literal = '\\377\\376\\105\\000\\147\\000\\147\\000\\040\\000\\074\\330\\163\\337';
            expect(core_1.PDFString.of(literal).decodeText()).toBe('Egg 🍳');
        });
        it(`can interpret PDFDocEncoded strings`, () => {
            const literal = 'a\\105b\\163\\0b6';
            expect(core_1.PDFString.of(literal).decodeText()).toBe('aEbs\0b6');
        });
        it(`can interpret PDFDocEncoded strings with EOLs and line breaks`, () => {
            const literal = 'a\nb\rc\\\nd\\\re';
            expect(core_1.PDFString.of(literal).decodeText()).toBe('a\nb\rcde');
        });
        it(`can interpret PDFDocEncoded strings with ignored escapes`, () => {
            const literal = 'a\nb\rc\\xd\\;';
            expect(core_1.PDFString.of(literal).decodeText()).toBe('a\nb\rcxd;');
        });
    });
    describe(`decoding to date`, () => {
        it(`can interpret date strings of the form D:YYYYMMDDHHmmSSOHH'mm`, () => {
            expect(core_1.PDFString.of(`D:20200321165011+01'01`).decodeDate()).toStrictEqual(new Date('2020-03-21T15:49:11Z'));
            expect(core_1.PDFString.of(`D:20200321165011-01'01`).decodeDate()).toStrictEqual(new Date('2020-03-21T17:51:11Z'));
            expect(core_1.PDFString.of(`D:20200321165011Z00'00`).decodeDate()).toStrictEqual(new Date('2020-03-21T16:50:11Z'));
        });
        it(`can interpret date strings of the form D:YYYYMMDDHHmmSSOHH`, () => {
            expect(core_1.PDFString.of('D:20200321165011+01').decodeDate()).toStrictEqual(new Date('2020-03-21T15:50:11Z'));
            expect(core_1.PDFString.of('D:20200321165011-01').decodeDate()).toStrictEqual(new Date('2020-03-21T17:50:11Z'));
            expect(core_1.PDFString.of('D:20200321165011Z00').decodeDate()).toStrictEqual(new Date('2020-03-21T16:50:11Z'));
        });
        it(`can interpret date strings of the form D:YYYYMMDDHHmmSSO`, () => {
            expect(core_1.PDFString.of('D:20200321165011Z').decodeDate()).toStrictEqual(new Date('2020-03-21T16:50:11Z'));
        });
        it(`can interpret date strings of the form D:YYYYMMDDHHmmSS`, () => {
            expect(core_1.PDFString.of('D:20200321165011').decodeDate()).toStrictEqual(new Date('2020-03-21T16:50:11Z'));
        });
        it(`can interpret date strings of the form D:YYYYMMDDHHmm`, () => {
            expect(core_1.PDFString.of('D:202003211650').decodeDate()).toStrictEqual(new Date('2020-03-21T16:50:00Z'));
        });
        it(`can interpret date strings of the form D:YYYYMMDDHH`, () => {
            expect(core_1.PDFString.of('D:2020032116').decodeDate()).toStrictEqual(new Date('2020-03-21T16:00:00Z'));
        });
        it(`can interpret date strings of the form D:YYYYMMDD`, () => {
            expect(core_1.PDFString.of('D:20200321').decodeDate()).toStrictEqual(new Date('2020-03-21T00:00:00Z'));
        });
        it(`can interpret date strings of the form D:YYYYMM`, () => {
            expect(core_1.PDFString.of('D:202003').decodeDate()).toStrictEqual(new Date('2020-03-01T00:00:00Z'));
        });
        it(`can interpret date strings of the form D:YYYY`, () => {
            expect(core_1.PDFString.of('D:2020').decodeDate()).toStrictEqual(new Date('2020-01-01T00:00:00Z'));
        });
    });
    it(`can provide its size in bytes`, () => {
        expect(core_1.PDFString.of('foobar').sizeInBytes()).toBe(8);
        expect(core_1.PDFString.of(' (foo(bar))').sizeInBytes()).toBe(13);
        expect(core_1.PDFString.of(')b\\a/z(').sizeInBytes()).toBe(9);
    });
    it(`can be serialized`, () => {
        const buffer = new Uint8Array(20).fill((0, utils_1.toCharCode)(' '));
        expect(core_1.PDFString.of(')(b\\a/))z(').copyBytesInto(buffer, 3)).toBe(12);
        expect(buffer).toEqual((0, utils_1.typedArrayFor)('   ()(b\\a/))z()     '));
    });
});
//# sourceMappingURL=PDFString.spec.js.map