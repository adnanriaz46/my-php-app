"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const pako_1 = __importDefault(require("pako"));
const index_1 = require("../../../src/index");
describe(`PDFContentStream`, () => {
    const context = index_1.PDFContext.create();
    const dict = index_1.PDFDict.withContext(context);
    const operators = [
        index_1.PDFOperator.of(index_1.PDFOperatorNames.BeginText),
        index_1.PDFOperator.of(index_1.PDFOperatorNames.SetFontAndSize, [index_1.PDFName.of('F1'), index_1.PDFNumber.of(24)]),
        index_1.PDFOperator.of(index_1.PDFOperatorNames.MoveText, [index_1.PDFNumber.of(100), index_1.PDFNumber.of(100)]),
        index_1.PDFOperator.of(index_1.PDFOperatorNames.ShowText, [index_1.PDFString.of('Hello World and stuff!')]),
        index_1.PDFOperator.of(index_1.PDFOperatorNames.EndText),
    ];
    it(`can be constructed from PDFContentStream.of(...)`, () => {
        expect(index_1.PDFContentStream.of(dict, operators, false)).toBeInstanceOf(index_1.PDFContentStream);
    });
    it(`allows operators to be pushed to the end of the stream`, () => {
        const stream = index_1.PDFContentStream.of(dict, [(0, index_1.pushGraphicsState)()], false);
        stream.push((0, index_1.moveText)(21, 99), (0, index_1.popGraphicsState)());
        expect(String(stream)).toEqual('<<\n/Length 13\n>>\n' +
            'stream\n' +
            'q\n' +
            '21 99 Td\n' +
            'Q\n' +
            '\nendstream');
    });
    it(`can be cloned`, () => {
        const original = index_1.PDFContentStream.of(dict, operators, false);
        const clone = original.clone();
        expect(clone).not.toBe(original);
        expect(String(clone)).toBe(String(original));
    });
    it(`can be converted to a string`, () => {
        expect(String(index_1.PDFContentStream.of(dict, operators, false))).toEqual('<<\n/Length 55\n>>\n' +
            'stream\n' +
            'BT\n' +
            '/F1 24 Tf\n' +
            '100 100 Td\n' +
            '(Hello World and stuff!) Tj\n' +
            'ET\n' +
            '\nendstream');
    });
    it(`can provide its size in bytes`, () => {
        expect(index_1.PDFContentStream.of(dict, operators, false).sizeInBytes()).toBe(89);
    });
    it(`can be serialized`, () => {
        const stream = index_1.PDFContentStream.of(dict, operators, false);
        const buffer = new Uint8Array(stream.sizeInBytes() + 3).fill((0, index_1.toCharCode)(' '));
        expect(stream.copyBytesInto(buffer, 2)).toBe(89);
        expect(buffer).toEqual((0, index_1.typedArrayFor)('  <<\n/Length 55\n>>\n' +
            'stream\n' +
            'BT\n' +
            '/F1 24 Tf\n' +
            '100 100 Td\n' +
            '(Hello World and stuff!) Tj\n' +
            'ET\n' +
            '\nendstream '));
    });
    it(`can be serialized when encoded`, () => {
        const contents = 'BT\n' +
            '/F1 24 Tf\n' +
            '100 100 Td\n' +
            '(Hello World and stuff!) Tj\n' +
            'ET\n';
        const encodedContents = pako_1.default.deflate(contents);
        const stream = index_1.PDFContentStream.of(dict, operators, true);
        const buffer = new Uint8Array(stream.sizeInBytes() + 3).fill((0, index_1.toCharCode)(' '));
        expect(stream.copyBytesInto(buffer, 2)).toBe(115);
        expect(buffer).toEqual((0, index_1.mergeIntoTypedArray)('  <<\n/Length 60\n/Filter /FlateDecode\n>>\n', 'stream\n', encodedContents, '\nendstream '));
    });
});
//# sourceMappingURL=PDFContentStream.spec.js.map