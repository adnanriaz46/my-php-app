"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fontkit_1 = __importDefault(require("@pdf-lib/fontkit"));
const standard_fonts_1 = require("@pdf-lib/standard-fonts");
const fs_1 = __importDefault(require("fs"));
const core_1 = require("../../src/core");
const utils_1 = require("../../src/utils");
const font = core_1.StandardFontEmbedder.for(standard_fonts_1.FontNames.Helvetica);
const textSize = 24;
const computeTextWidth = (text) => font.widthOfTextAtSize(text, textSize);
describe(`breakTextIntoLines`, () => {
    it(`handles empty wordBreaks arrays`, () => {
        const input = 'foobar-quxbaz';
        const expected = ['foobar-quxbaz'];
        const actual = (0, utils_1.breakTextIntoLines)(input, [], 21, computeTextWidth);
        expect(actual).toEqual(expected);
    });
    it(`handles trailing newlines`, () => {
        const input = 'foo\n';
        const expected = ['foo'];
        const actual = (0, utils_1.breakTextIntoLines)(input, [], 21, computeTextWidth);
        expect(actual).toEqual(expected);
    });
    it(`handles trailing carriage returns`, () => {
        const input = 'foo\r';
        const expected = ['foo'];
        const actual = (0, utils_1.breakTextIntoLines)(input, [], 21, computeTextWidth);
        expect(actual).toEqual(expected);
    });
    it(`always breaks lines when EOLs are encountered`, () => {
        const input = 'foo\nbar-qux\rbaz\n';
        const expected = ['foo', 'bar-qux', 'baz'];
        const actual = (0, utils_1.breakTextIntoLines)(input, [], 90000, computeTextWidth);
        expect(actual).toEqual(expected);
    });
    it(`breaks at the last possible 'wordBreak' before exceeding 'maxWidth' (1)`, () => {
        const input = 'Lorem Test ipsum dolor sit amet, consectetur adipiscing\nelit';
        const expected = [
            'Lorem T',
            'est ipsu',
            'm dolor s',
            'it amet, c',
            'onsectet',
            'ur adipis',
            'cing',
            'elit',
        ];
        const actual = (0, utils_1.breakTextIntoLines)(input, ['', 'Test'], 100, computeTextWidth);
        expect(actual).toEqual(expected);
    });
    it(`breaks at the last possible 'wordBreak' before exceeding 'maxWidth' (2)`, () => {
        const input = 'Foo%bar%baz';
        const expected = ['Foo%', 'bar%baz'];
        const actual = (0, utils_1.breakTextIntoLines)(input, ['%'], 100, computeTextWidth);
        expect(actual).toEqual(expected);
    });
    it(`handles non-ascii code points and empty breaks`, async () => {
        const sourceHansBytes = fs_1.default.readFileSync('assets/fonts/source_hans_jp/SourceHanSerifJP-Regular.otf');
        const sourceHansFont = await core_1.CustomFontEmbedder.for(fontkit_1.default, sourceHansBytes);
        const input = '遅未亮惑職界転藤柔索名午納，問通桑転加料演載満経信回込町者訟窃。';
        const expected = [
            '遅未亮惑職',
            '界転藤柔索',
            '名午納，問',
            '通桑転加料',
            '演載満経信',
            '回込町者訟',
            '窃。',
        ];
        const actual = (0, utils_1.breakTextIntoLines)(input, [''], 125, (text) => sourceHansFont.widthOfTextAtSize(text, 24));
        expect(actual).toEqual(expected);
    });
});
//# sourceMappingURL=strings.spec.js.map