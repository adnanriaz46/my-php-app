"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultOptionListAppearanceProvider = exports.defaultDropdownAppearanceProvider = exports.defaultTextFieldAppearanceProvider = exports.defaultButtonAppearanceProvider = exports.defaultRadioGroupAppearanceProvider = exports.defaultCheckBoxAppearanceProvider = exports.normalizeAppearance = void 0;
const operations_1 = require("../operations");
const colors_1 = require("../colors");
const rotations_1 = require("../rotations");
const layout_1 = require("../text/layout");
const alignment_1 = require("../text/alignment");
const operators_1 = require("../operators");
const utils_1 = require("../../utils");
/********************* Appearance Provider Functions **************************/
const normalizeAppearance = (appearance) => {
    if ('normal' in appearance)
        return appearance;
    return { normal: appearance };
};
exports.normalizeAppearance = normalizeAppearance;
// Examples:
//   `/Helv 12 Tf` -> ['/Helv 12 Tf', 'Helv', '12']
//   `/HeBo 8.00 Tf` -> ['/HeBo 8 Tf', 'HeBo', '8.00']
const tfRegex = /\/([^\s]+)\s+(\d+(?:\.\d+)?)\s+Tf/;
const getDefaultFontSize = (field) => {
    const da = field.getDefaultAppearance() ?? '';
    const daMatch = (0, utils_1.findLastMatch)(da, tfRegex).match ?? [];
    const defaultFontSize = Number(daMatch[2]);
    return isFinite(defaultFontSize) ? defaultFontSize : undefined;
};
// Examples:
//   `0.3 g` -> ['0.3', 'g']
//   `0.3 1 .3 rg` -> ['0.3', '1', '.3', 'rg']
//   `0.3 1 .3 0 k` -> ['0.3', '1', '.3', '0', 'k']
const colorRegex = /(\d+(?:\.\d+)?)\s*(\d+(?:\.\d+)?)?\s*(\d+(?:\.\d+)?)?\s*(\d+(?:\.\d+)?)?\s+(g|rg|k)/;
const getDefaultColor = (field) => {
    const da = field.getDefaultAppearance() ?? '';
    const daMatch = (0, utils_1.findLastMatch)(da, colorRegex).match;
    const [, c1, c2, c3, c4, colorSpace] = daMatch ?? [];
    if (colorSpace === 'g' && c1) {
        return (0, colors_1.grayscale)(Number(c1));
    }
    if (colorSpace === 'rg' && c1 && c2 && c3) {
        return (0, colors_1.rgb)(Number(c1), Number(c2), Number(c3));
    }
    if (colorSpace === 'k' && c1 && c2 && c3 && c4) {
        return (0, colors_1.cmyk)(Number(c1), Number(c2), Number(c3), Number(c4));
    }
    return undefined;
};
const updateDefaultAppearance = (field, color, font, fontSize = 0) => {
    const da = [
        (0, colors_1.setFillingColor)(color).toString(),
        (0, operators_1.setFontAndSize)(font?.name ?? 'dummy__noop', fontSize).toString(),
    ].join('\n');
    field.setDefaultAppearance(da);
};
const defaultCheckBoxAppearanceProvider = (checkBox, widget) => {
    // The `/DA` entry can be at the widget or field level - so we handle both
    const widgetColor = getDefaultColor(widget);
    const fieldColor = getDefaultColor(checkBox.acroField);
    const rectangle = widget.getRectangle();
    const ap = widget.getAppearanceCharacteristics();
    const bs = widget.getBorderStyle();
    const borderWidth = bs?.getWidth() ?? 0;
    const rotation = (0, rotations_1.reduceRotation)(ap?.getRotation());
    const { width, height } = (0, rotations_1.adjustDimsForRotation)(rectangle, rotation);
    const rotate = (0, operations_1.rotateInPlace)({ ...rectangle, rotation });
    const black = (0, colors_1.rgb)(0, 0, 0);
    const borderColor = (0, colors_1.componentsToColor)(ap?.getBorderColor()) ?? black;
    const normalBackgroundColor = (0, colors_1.componentsToColor)(ap?.getBackgroundColor());
    const downBackgroundColor = (0, colors_1.componentsToColor)(ap?.getBackgroundColor(), 0.8);
    // Update color
    const textColor = widgetColor ?? fieldColor ?? black;
    if (widgetColor) {
        updateDefaultAppearance(widget, textColor);
    }
    else {
        updateDefaultAppearance(checkBox.acroField, textColor);
    }
    const options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        thickness: 1.5,
        borderWidth,
        borderColor,
        markColor: textColor,
    };
    return {
        normal: {
            on: [
                ...rotate,
                ...(0, operations_1.drawCheckBox)({
                    ...options,
                    color: normalBackgroundColor,
                    filled: true,
                }),
            ],
            off: [
                ...rotate,
                ...(0, operations_1.drawCheckBox)({
                    ...options,
                    color: normalBackgroundColor,
                    filled: false,
                }),
            ],
        },
        down: {
            on: [
                ...rotate,
                ...(0, operations_1.drawCheckBox)({
                    ...options,
                    color: downBackgroundColor,
                    filled: true,
                }),
            ],
            off: [
                ...rotate,
                ...(0, operations_1.drawCheckBox)({
                    ...options,
                    color: downBackgroundColor,
                    filled: false,
                }),
            ],
        },
    };
};
exports.defaultCheckBoxAppearanceProvider = defaultCheckBoxAppearanceProvider;
const defaultRadioGroupAppearanceProvider = (radioGroup, widget) => {
    // The `/DA` entry can be at the widget or field level - so we handle both
    const widgetColor = getDefaultColor(widget);
    const fieldColor = getDefaultColor(radioGroup.acroField);
    const rectangle = widget.getRectangle();
    const ap = widget.getAppearanceCharacteristics();
    const bs = widget.getBorderStyle();
    const borderWidth = bs?.getWidth() ?? 0;
    const rotation = (0, rotations_1.reduceRotation)(ap?.getRotation());
    const { width, height } = (0, rotations_1.adjustDimsForRotation)(rectangle, rotation);
    const rotate = (0, operations_1.rotateInPlace)({ ...rectangle, rotation });
    const black = (0, colors_1.rgb)(0, 0, 0);
    const borderColor = (0, colors_1.componentsToColor)(ap?.getBorderColor()) ?? black;
    const normalBackgroundColor = (0, colors_1.componentsToColor)(ap?.getBackgroundColor());
    const downBackgroundColor = (0, colors_1.componentsToColor)(ap?.getBackgroundColor(), 0.8);
    // Update color
    const textColor = widgetColor ?? fieldColor ?? black;
    if (widgetColor) {
        updateDefaultAppearance(widget, textColor);
    }
    else {
        updateDefaultAppearance(radioGroup.acroField, textColor);
    }
    const options = {
        x: width / 2,
        y: height / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth,
        borderColor,
        dotColor: textColor,
    };
    return {
        normal: {
            on: [
                ...rotate,
                ...(0, operations_1.drawRadioButton)({
                    ...options,
                    color: normalBackgroundColor,
                    filled: true,
                }),
            ],
            off: [
                ...rotate,
                ...(0, operations_1.drawRadioButton)({
                    ...options,
                    color: normalBackgroundColor,
                    filled: false,
                }),
            ],
        },
        down: {
            on: [
                ...rotate,
                ...(0, operations_1.drawRadioButton)({
                    ...options,
                    color: downBackgroundColor,
                    filled: true,
                }),
            ],
            off: [
                ...rotate,
                ...(0, operations_1.drawRadioButton)({
                    ...options,
                    color: downBackgroundColor,
                    filled: false,
                }),
            ],
        },
    };
};
exports.defaultRadioGroupAppearanceProvider = defaultRadioGroupAppearanceProvider;
const defaultButtonAppearanceProvider = (button, widget, font) => {
    // The `/DA` entry can be at the widget or field level - so we handle both
    const widgetColor = getDefaultColor(widget);
    const fieldColor = getDefaultColor(button.acroField);
    const widgetFontSize = getDefaultFontSize(widget);
    const fieldFontSize = getDefaultFontSize(button.acroField);
    const rectangle = widget.getRectangle();
    const ap = widget.getAppearanceCharacteristics();
    const bs = widget.getBorderStyle();
    const captions = ap?.getCaptions();
    const normalText = captions?.normal ?? '';
    const downText = captions?.down ?? normalText ?? '';
    const borderWidth = bs?.getWidth() ?? 0;
    const rotation = (0, rotations_1.reduceRotation)(ap?.getRotation());
    const { width, height } = (0, rotations_1.adjustDimsForRotation)(rectangle, rotation);
    const rotate = (0, operations_1.rotateInPlace)({ ...rectangle, rotation });
    const black = (0, colors_1.rgb)(0, 0, 0);
    const borderColor = (0, colors_1.componentsToColor)(ap?.getBorderColor());
    const normalBackgroundColor = (0, colors_1.componentsToColor)(ap?.getBackgroundColor());
    const downBackgroundColor = (0, colors_1.componentsToColor)(ap?.getBackgroundColor(), 0.8);
    const bounds = {
        x: borderWidth,
        y: borderWidth,
        width: width - borderWidth * 2,
        height: height - borderWidth * 2,
    };
    const normalLayout = (0, layout_1.layoutSinglelineText)(normalText, {
        alignment: alignment_1.TextAlignment.Center,
        fontSize: widgetFontSize ?? fieldFontSize,
        font,
        bounds,
    });
    const downLayout = (0, layout_1.layoutSinglelineText)(downText, {
        alignment: alignment_1.TextAlignment.Center,
        fontSize: widgetFontSize ?? fieldFontSize,
        font,
        bounds,
    });
    // Update font size and color
    const fontSize = Math.min(normalLayout.fontSize, downLayout.fontSize);
    const textColor = widgetColor ?? fieldColor ?? black;
    if (widgetColor || widgetFontSize !== undefined) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
    }
    else {
        updateDefaultAppearance(button.acroField, textColor, font, fontSize);
    }
    const options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth,
        borderColor,
        textColor,
        font: font.name,
        fontSize,
    };
    return {
        normal: [
            ...rotate,
            ...(0, operations_1.drawButton)({
                ...options,
                color: normalBackgroundColor,
                textLines: [normalLayout.line],
            }),
        ],
        down: [
            ...rotate,
            ...(0, operations_1.drawButton)({
                ...options,
                color: downBackgroundColor,
                textLines: [downLayout.line],
            }),
        ],
    };
};
exports.defaultButtonAppearanceProvider = defaultButtonAppearanceProvider;
const defaultTextFieldAppearanceProvider = (textField, widget, font) => {
    // The `/DA` entry can be at the widget or field level - so we handle both
    const widgetColor = getDefaultColor(widget);
    const fieldColor = getDefaultColor(textField.acroField);
    const widgetFontSize = getDefaultFontSize(widget);
    const fieldFontSize = getDefaultFontSize(textField.acroField);
    const rectangle = widget.getRectangle();
    const ap = widget.getAppearanceCharacteristics();
    const bs = widget.getBorderStyle();
    const text = textField.getText() ?? '';
    const borderWidth = bs?.getWidth() ?? 0;
    const rotation = (0, rotations_1.reduceRotation)(ap?.getRotation());
    const { width, height } = (0, rotations_1.adjustDimsForRotation)(rectangle, rotation);
    const rotate = (0, operations_1.rotateInPlace)({ ...rectangle, rotation });
    const black = (0, colors_1.rgb)(0, 0, 0);
    const borderColor = (0, colors_1.componentsToColor)(ap?.getBorderColor());
    const normalBackgroundColor = (0, colors_1.componentsToColor)(ap?.getBackgroundColor());
    let textLines;
    let fontSize;
    const padding = textField.isCombed() ? 0 : 1;
    const bounds = {
        x: borderWidth + padding,
        y: borderWidth + padding,
        width: width - (borderWidth + padding) * 2,
        height: height - (borderWidth + padding) * 2,
    };
    if (textField.isMultiline()) {
        const layout = (0, layout_1.layoutMultilineText)(text, {
            alignment: textField.getAlignment(),
            fontSize: widgetFontSize ?? fieldFontSize,
            font,
            bounds,
        });
        textLines = layout.lines;
        fontSize = layout.fontSize;
    }
    else if (textField.isCombed()) {
        const layout = (0, layout_1.layoutCombedText)(text, {
            fontSize: widgetFontSize ?? fieldFontSize,
            font,
            bounds,
            cellCount: textField.getMaxLength() ?? 0,
        });
        textLines = layout.cells;
        fontSize = layout.fontSize;
    }
    else {
        const layout = (0, layout_1.layoutSinglelineText)(text, {
            alignment: textField.getAlignment(),
            fontSize: widgetFontSize ?? fieldFontSize,
            font,
            bounds,
        });
        textLines = [layout.line];
        fontSize = layout.fontSize;
    }
    // Update font size and color
    const textColor = widgetColor ?? fieldColor ?? black;
    if (widgetColor || widgetFontSize !== undefined) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
    }
    else {
        updateDefaultAppearance(textField.acroField, textColor, font, fontSize);
    }
    const options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth: borderWidth ?? 0,
        borderColor,
        textColor,
        font: font.name,
        fontSize,
        color: normalBackgroundColor,
        textLines,
        padding,
    };
    return [...rotate, ...(0, operations_1.drawTextField)(options)];
};
exports.defaultTextFieldAppearanceProvider = defaultTextFieldAppearanceProvider;
const defaultDropdownAppearanceProvider = (dropdown, widget, font) => {
    // The `/DA` entry can be at the widget or field level - so we handle both
    const widgetColor = getDefaultColor(widget);
    const fieldColor = getDefaultColor(dropdown.acroField);
    const widgetFontSize = getDefaultFontSize(widget);
    const fieldFontSize = getDefaultFontSize(dropdown.acroField);
    const rectangle = widget.getRectangle();
    const ap = widget.getAppearanceCharacteristics();
    const bs = widget.getBorderStyle();
    const text = dropdown.getSelected()[0] ?? '';
    const borderWidth = bs?.getWidth() ?? 0;
    const rotation = (0, rotations_1.reduceRotation)(ap?.getRotation());
    const { width, height } = (0, rotations_1.adjustDimsForRotation)(rectangle, rotation);
    const rotate = (0, operations_1.rotateInPlace)({ ...rectangle, rotation });
    const black = (0, colors_1.rgb)(0, 0, 0);
    const borderColor = (0, colors_1.componentsToColor)(ap?.getBorderColor());
    const normalBackgroundColor = (0, colors_1.componentsToColor)(ap?.getBackgroundColor());
    const padding = 1;
    const bounds = {
        x: borderWidth + padding,
        y: borderWidth + padding,
        width: width - (borderWidth + padding) * 2,
        height: height - (borderWidth + padding) * 2,
    };
    const { line, fontSize } = (0, layout_1.layoutSinglelineText)(text, {
        alignment: alignment_1.TextAlignment.Left,
        fontSize: widgetFontSize ?? fieldFontSize,
        font,
        bounds,
    });
    // Update font size and color
    const textColor = widgetColor ?? fieldColor ?? black;
    if (widgetColor || widgetFontSize !== undefined) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
    }
    else {
        updateDefaultAppearance(dropdown.acroField, textColor, font, fontSize);
    }
    const options = {
        x: 0 + borderWidth / 2,
        y: 0 + borderWidth / 2,
        width: width - borderWidth,
        height: height - borderWidth,
        borderWidth: borderWidth ?? 0,
        borderColor,
        textColor,
        font: font.name,
        fontSize,
        color: normalBackgroundColor,
        textLines: [line],
        padding,
    };
    return [...rotate, ...(0, operations_1.drawTextField)(options)];
};
exports.defaultDropdownAppearanceProvider = defaultDropdownAppearanceProvider;
const defaultOptionListAppearanceProvider = (optionList, widget, font) => {
    // The `/DA` entry can be at the widget or field level - so we handle both
    const widgetColor = getDefaultColor(widget);
    const fieldColor = getDefaultColor(optionList.acroField);
    const widgetFontSize = getDefaultFontSize(widget);
    const fieldFontSize = getDefaultFontSize(optionList.acroField);
    const rectangle = widget.getRectangle();
    const ap = widget.getAppearanceCharacteristics();
    const bs = widget.getBorderStyle();
    const borderWidth = bs?.getWidth() ?? 0;
    const rotation = (0, rotations_1.reduceRotation)(ap?.getRotation());
    const { width, height } = (0, rotations_1.adjustDimsForRotation)(rectangle, rotation);
    const rotate = (0, operations_1.rotateInPlace)({ ...rectangle, rotation });
    const black = (0, colors_1.rgb)(0, 0, 0);
    const borderColor = (0, colors_1.componentsToColor)(ap?.getBorderColor());
    const normalBackgroundColor = (0, colors_1.componentsToColor)(ap?.getBackgroundColor());
    const options = optionList.getOptions();
    const selected = optionList.getSelected();
    if (optionList.isSorted())
        options.sort();
    let text = '';
    for (let idx = 0, len = options.length; idx < len; idx++) {
        text += options[idx];
        if (idx < len - 1)
            text += '\n';
    }
    const padding = 1;
    const bounds = {
        x: borderWidth + padding,
        y: borderWidth + padding,
        width: width - (borderWidth + padding) * 2,
        height: height - (borderWidth + padding) * 2,
    };
    const { lines, fontSize, lineHeight } = (0, layout_1.layoutMultilineText)(text, {
        alignment: alignment_1.TextAlignment.Left,
        fontSize: widgetFontSize ?? fieldFontSize,
        font,
        bounds,
    });
    const selectedLines = [];
    for (let idx = 0, len = lines.length; idx < len; idx++) {
        const line = lines[idx];
        if (selected.includes(line.text))
            selectedLines.push(idx);
    }
    const blue = (0, colors_1.rgb)(153 / 255, 193 / 255, 218 / 255);
    // Update font size and color
    const textColor = widgetColor ?? fieldColor ?? black;
    if (widgetColor || widgetFontSize !== undefined) {
        updateDefaultAppearance(widget, textColor, font, fontSize);
    }
    else {
        updateDefaultAppearance(optionList.acroField, textColor, font, fontSize);
    }
    return [
        ...rotate,
        ...(0, operations_1.drawOptionList)({
            x: 0 + borderWidth / 2,
            y: 0 + borderWidth / 2,
            width: width - borderWidth,
            height: height - borderWidth,
            borderWidth: borderWidth ?? 0,
            borderColor,
            textColor,
            font: font.name,
            fontSize,
            color: normalBackgroundColor,
            textLines: lines,
            lineHeight,
            selectedColor: blue,
            selectedLines,
            padding,
        }),
    ];
};
exports.defaultOptionListAppearanceProvider = defaultOptionListAppearanceProvider;
//# sourceMappingURL=appearances.js.map